# 콘서트 대기열 시스템에서 발생할 수 있는 동시성 이슈 보고서

---

## 동시성 이슈가 발생할 수 있는 기능

## 1. 좌석 예약

### 원인

- 여러 사용자가 동시에 같은 좌석을 조회 하고 예약 가능 상태라면 해당 좌석에 동시에 예약 요청을 할 수 있기 때문.
- 동시성 이슈 예상 시나리오
    1. 사용자 A와 B가 동시에 예약 가능 좌석 조회
    2. A와 B가 예약 상태가 아닌 같은 좌석에 동시에 예약 요청
    3. 이렇게 되면 A와 B에게 같은 좌석이 배정되게 됨

    - 그렇기 때문에 동시성 제어를 통해서 좌석당 한명의 사용자만 예약 가능하도록 동시성 제어
- 발생 빈도 : 높음
- 재처리 여부 : X

### 동시성 이슈 해결 방안

#### 1. 낙관적 락 (Optimistic Lock)

- 구현 난이도 : 쉬움
- Entity에 version 필드를 추가.
- 동시성 이슈가 발생하여 처음 조회했을 때와 version이 일치하지 않는다면
  ObjectOptimisticLockingFailureException 예외 발생.
- 경합이 많이 발생하는 상황에서는 재처리 로직을 구현해야 하고 성능 저하가 발생할 수 있지만 해당 기능은 한번의 요청만 성공하면 되기 때문에 재처리 필요 X.
- 커밋 시점에 예약 여부를 확인 할 수 있음.

#### 테스트 수행 결과

![좌석예약 낙관락](./images/좌석예약%20낙관락.png)

#### 2. 비관적 락 (Pessimistic Lock)

- 구현 난이도 : 쉬움
- 베타락(X-Lock)으로 동시성 문제 해소.
- 조회 부터 락을 점유하기 때문에 요청이 많아지면 성능 저하가 발생할 수 있다.

#### 테스트 수행 결과

![좌석예약 비관락](./images/좌석예약%20비관락.png)

#### 3. 분산 락 (Redisson - Distributed Lock)

- 구현 난이도 : 어려움
- SpinLock 방식의 Lettuce 대신 Pub/Sub 방식의 Redisson을 사용하여 분산 락 구현.
    - SpinLock의 경우 lock을 획득할 때까지 계속 확인하기 때문에 하나의 스레드가 lock을 오래 점유할 경우
      성능 저하가 발생됨.
- 분산 환경에서 동시성 문제를 해결할 수 있음.
- 락을 점유해야 트랜잭션이 시작되기 때문에 요청이 몰리면 DB 부하를 줄일 수 있지만 대기하는 시간이 길어질 수 있음.

#### 테스트 수행 결과

![좌석예약 분산락](./images/좌석예약%20분산락.png)

### 의사결정

- 좌석 예약 기능에서는 경합 발생 빈도가 높아서 처음에 비관적 락과 분산 락을 고려했지만 요청이 많아질수록 성능 저하가
  발생할 것으로 예상되어 낙관적 락을 선택.
    - 실제로 테스트 진행시 차이가 많이 나지 않지만 평균적으로 낙관적 락이 좀 더 빠름.
- 먼저 비관적 락의 경우 트랜잭션이 시작되고 조회 작업부터 락이 걸리기 때문에 성능 저하가 발생할 것으로 판단.
- 분산 락의 경우 분산 환경에서 동시성 제어가 가능하지만 현재 단일 DB 이기도 하고 좌석 하나의 요청만 성공하면 되는데
  실패시 사용자에게 불필요한 대기시간을 발생할 수 있다고 판단.
- 낙관적 락의 경우 재처리 로직이 포함될 경우 성능적으로 더 안좋을 수 있지만 해당 기능의 경우 한번만 요청이 성공하면 되기
  때문에 적합하고 대기열을 통해 어느정도 부하가 분산된다고 생각되어 적합하다고 판단.

---

## 2. 포인트 충전

- 동일한 사용자가 잔액 충전 요청을 여러번 시도 할 수 있다.
- 동시성 이슈 예상 시나리오
    1. 사용자가 충전 버튼을 여러번(따닥) 클릭할 수 있다.
    2. 사용자가 여러 브라우저를 통해 동시에 요청할 수 있다.

    - 발생 빈도나 가능성은 높지 않지만 돈과 관련된 민감한 사항이기 때문에 고려할 필요가 있다고 판단.
- 발생 빈도: 낮음
- 재처리 여부 : 필요.

### 동시성 이슈 해결 방안

#### 1. 낙관적 락 (Optimistic Lock)

- 구현 난이도 : 쉬움
- 요청 실패시 재처리 로직이 필요함.
- 요청이 많아지면, 재처리가 무조건 성공한다는 보장이 없기 때문에 실패할 수 있음.
- 성공할 때까지 요청이 재시도를 하게되면 성능 저하될 수 있음.

#### 테스트 수행 결과

![포인트 충전 낙관락](./images/포인트%20충전%20-%20낙관락.png)

#### 2. 비관적 락 (Pessimistic Lock)

- 구현 난이도 : 쉬움
- 낙관적 락과 비교했을 때 데이터 정합성을 보장해주기 때문에 성공 처리를 보장.
- 하지만 마찬가지로 요청이 많아져서 락 점유시간이 길어지면 성능 저하가 발생할 수 있음.

#### 테스트 수행 결과

![포인트 충전 비관락](./images/포인트%20충전-비관락.png)

#### 3. 분산 락 (Redisson - Distributed Lock)

- 구현 난이도 : 보통
- 해당 기능에서는 동시성 이슈 가능성이 높지 않기 때문에 자원 낭비가 될 수 있음.(오버 엔지니어링)
- 분산 환경에서 동시성 문제를 해결할 수 있음

#### 테스트 수행 결과

![포인트 충전 분산락](./images/포인트%20충전-%20분산락.png)

### 의사결정

- 잔액 충전의 기능은 동시성 이슈 해결 방안으로 비관적 락을 선택.
- 비관적 락의 경우 데이터 정합성이 보장되고 요청이 많아지면 성능 저하가 발생할 수 있지만 해당 기능은
  좌석 예약에 비해 동시성 문제 발생 가능성이 낮기 때문에 괜찮을 것이라 판단.
    - 실제 속도 면에서도 낙관적 락이 제일 느린편이였고 분산락과 차이는 거의 나지 않지만 분산락 보다 빨랐음.
- 낙관적 락의 경우 실패하면 재시도 로직을 추가해야 하며, 요청이 많아질 경우 제대로 처리 된다는 보장이 없기 때문에
  적합하지 않다고 판단.
- 분산락의 경우 분산환경에서 동시성 문제를 해결할 수 있지만 위에 언급한 것처럼 동시 요청이 거의 없을 것이라
  생각되어 적합하지 않다고 판단.

---

## 3. 결제

- 동일한 사용자가 결제 요청을 여러번 시도할 수 있다.
- 동시성 이슈 예상 시나리오
    1. 사용자가 결제 버튼을 여러번(따닥) 클릭할 수 있다.
    2. 사용자가 여러 브라우저를 통해 동시에 요청할 수 있다.

    - 잔액 충전과 마찬가지로 발생 빈도나 가능성은 높지 않지만 돈과 관련된 민감한 사항이기 때문에 고려할 필요가 있다고 판단.
- 발생 빈도: 낮음
- 재처리 여부 : 불필요.

### 동시성 이슈 해결 방안

#### 1. 낙관적 락 (Optimistic Lock)

- 구현 난이도 : 쉬움
- 좌석에 대해 결제는 한번만 되어야 하기 때문에 재처리 필요 없다고 판단.
- 좌석의 예약 여부를 커밋 시점에 확인 가능.

#### 테스트 수행 결과

![결제 낙관락](./images/결제%20-%20낙관락.png)

#### 2. 비관적 락 (Pessimistic Lock)

- 구현 난이도 : 쉬움
- 조회 작업부터 락을 사용하기 때문에 성능 저하가 발생할 수 있음.
- 요청 하나에 대해서만 성공해야 하기 때문에 불필요 대기시간이 발생할 수 있음.

#### 테스트 수행 결과

![결제 비관락](./images/결제%20-%20비관락.png)

#### 3. 분산 락 (Redisson - Distributed Lock)

- 구현 난이도 : 보통
- 예약 PK(reservationId)를 통해 구현.
- 락을 점유해야 트랜잭션이 시작되기 때문에 DB 부하를 줄일 수 있다.
- 스케쥴링, 결제, 예약 취소등 예약 상태가 변경되는 시나리오들이 있어서 분산락을 통해 동시성 문제를 해소할 수 있다.

#### 테스트 수행 결과

![결제 분산락](./images/결제%20-%20분산락.png)

### 의사결정

- 결제 기능은 동시성 이슈 해결 방안으로 분산 락을 선택.
- 비관적 락보다 DB 커넥션을 점유하는 시간이 없기 때문에 성능 저하를 최소화 할 수 있다.
- 다양한 시나리오에 대응되는 유연성 제공 및 여러 인스턴스 간 동기화를 쉽게 구현할 수 있다.
    - 좌석 예약 결제뿐만 아니라, 예약 취소나 임시 예약 만료 스케쥴링등 다양한 시나리오에 결제 상태 변경에 대한
      동시성 문제가 발생할 수 있어서 분산락이 적합하다고 판단.